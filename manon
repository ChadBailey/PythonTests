#!/bin/bash
helpme() {
	    cat <<EOF
This script search online man pages in various ways.
Usage: manon [packagename] [option1] [option2]
  Option1:
    --help				This usage screen.
    --online [option2]			Use online services to retrieve requested man page (die.net, mankier.com and man.he.net)
					If option2 is ommited , starting from die.net
    --apt				Extract and display the man page from the deb package without downloading it. 
    --down				Download the deb package (apt-get -d pkg), extract man page and then delete deb package.
    --debian			Search particulary in debian manpages online platform 
  
  Option 2:
	--mankier			Skip die.net look at mankier.com
	--manhenet			Skip die.net and mankier.com and look directly in man.he.net
	--browser			When used with --debian instead of displaying man page in terminal opens the default browser.
	--nodelete			When used with --down the deb package will not be deleted.


EOF
}	

[[ -z $1 || -z $2 ]] && helpme && exit

if [[ $2 == "--online" || $2 == "--online-nogui" ]]; then
	title=$1
	unset dt0 dt data mson loopon
	loopon=1
	if [[ -z $3 ]]; then
		echo "Trying at die.net"
		#dt=$(links -dump https://linux.die.net/man/1/$1)
		pkg=${1:0:1} #get the first char
		dt0+=($(links -dump "https://linux.die.net/man/$pkg.html" |grep -E "^( )*+$1+\([0-9]\)")) #search die.net alphabetical pages
		#declare -p dt0 && exit
		if [[ ${#dt0[@]} -gt 1 ]];then
			while [[ $loopon -eq 1 ]]; do
				#declare -p dt0 |sed 's/declare -a dt0=//g' |tr -d '()' |tr ' ' '\n'
				declare -p dt0 |sed 's/declare -a dt0=(//g' |tr ' ' '\n' |sed 's/)$//g'
				read -p "Select man pages to display by id or q to quit : " mson #case of wait : gives three different man pages (wait(1) wait(2) wait(3))
				echo "You selected: $mson"
				if [[ $mson == "q" ]]; then
					echo "exiting"
					loopon=0
					exit 1
				elif [[ $mson -le $((${#dt0[@]}-1)) ]]; then
					echo "Display ${dt0[$mson]}" 	#for some reason pressing any letter assigns dt0[0] , obviously else goes into here instead of the last else
					loopon=0
					dt=${dt0[$mson]}
				elif [[ $mson -gt $((${#dt0[@]}-1)) ]]; then
					echo "out of range - try again"
				else
					echo "Invalid Selection - Try Again"
				fi
			done


#			for i in ${dt0[@]};do 
#				if [[ $(awk -F"\(" '{print $1}'<<<$i |tr -d " ") == "$1" ]];then
#					dt=$i
#					echo "found $i == $dt"
#				fi
#			done
		else
			dt=$dt0
		fi
#		exit
		if [[ -z $dt ]]; then 
			echo "$1 not available in die.net"
			data="Man page Not Found in die.net"
		else
			manname=$(awk -F"\(" '{print $1}'<<<$dt |tr -d " ")
			section=$(awk -F"\(" '{print $2}'<<<$dt |cut -d")" -f1 |tr -d " ")
			echo "$dt - $manname - $section"
			data=$(links -dump https://linux.die.net/man/$section/$manname)
			tit="/die.net online"
		fi
	fi
	
	if [[ $data == *"Not Found"* || $3 == "--mankier" ]]; then
		echo "die.net skipped. Trying mankier.com"
		unset dt data
		data=$(links -dump  "https://www.mankier.com/?q=$1") 
		#Mind the fantastic redirection of mankier. If package is foung, then you are automatically redirected to man page and you don't have to worry about man section (1..8)'
		tit="/mankier online"
	fi

	if [[ $data == *"No results"* || $3 == "--manhenet" ]]; then #mankier return No results in search form if package is not found.
		echo "die.net and mankier.com skpped . Trying man.he.net"
		unset data
		data=$(links -dump  "http://man.he.net/?topic=$1&section=all") #Mind that man.he.net supports section=all and thus you don't need to specify 1..8'
		tit="/man.he.net online"
	fi

	if [[ $data == *"No matches"* ]]; then #man.he.net returns no matches for package if the package does not exist
		echo "No manual found either at die.net, mankier.com or man.he.net. Exiting"
		exit
	fi
	if [[ $2 == "--online-nogui" ]];then
		echo "$data" |less #display in terminal rather than yad
	else
		yad --text-info<<<"$data" --height=500 --width=800 --center --title="$title$tit Manual " --wrap --show-uri --no-markup &	
	fi
fi

if [[ $2 == "--apt" ]]; then
	loop=1
	pkg="$1"
	aptpkg=$(apt list $pkg 2>/dev/null |grep $1 |cut -d" " -f1 |cut -d"," -f1)
	echo "Package: $aptpkg"
	aptresp=$(apt-get --print-uris download $aptpkg 2>&1)
	#initially i did it with --print-uris install but in case of yade, there are three deb files returned.
	#on the other hand , the download option returns only the required yade package.
	if [[ "$aptresp" == *"Unable to locate package"* ]];then
		echo "Error. Either wrong package name or other error. Raw output of apt:"
		apt-get --print-uris install $aptpkg
		exit 1
	fi

	deb=$(grep "/$pkg" <<<"$aptresp" |cut -d" " -f1 |sed s/\'//g)
	echo "deb file : $deb"
	manpage+=($(curl -sL -o- $deb |dpkg -c /dev/stdin |grep "man/man" |grep -vE "\/$" |awk '{print $NF}'))

	while [[ $loop -eq 1 ]]; do
		if [[ -z $manpage ]];then
			echo "No man pages found in deb package - These are the contents of the $deb:"
			curl -sL -o- $deb |dpkg -c /dev/stdin
			exit 1
		else
			echo "man page found: ${#manpage[@]}"
			declare -p manpage |sed 's/declare -a manpage=(//g' |tr ' ' '\n' |sed 's/)$//g'
		fi
		
		if [[ ${#manpage[@]} -eq 1 ]]; then
			echo "One man page found - Display "
			curl -sL -o- $deb |dpkg-deb --fsys-tarfile /dev/stdin |tar -xO $manpage |man /dev/stdin
			loop=0
		else
			read -p "Select man pages to display by id or press a for all  - q to quit : " ms
			if [[ $ms == "a" ]]; then 
				echo "Display all"
				curl -sL -o- $deb |dpkg-deb --fsys-tarfile /dev/stdin |tar -xO ${manpage[@]} |man /dev/stdin				
			elif [[ $ms == "q" ]]; then
				echo "exiting"
				loop=0
			elif [[ $ms -le $((${#manpage[@]}-1)) ]]; then
				echo "Display ${manpage[$ms]}"
				curl -sL -o- $deb |dpkg-deb --fsys-tarfile /dev/stdin |tar -xO ${manpage[$ms]} |man /dev/stdin
			elif [[ $ms -gt $((${#manpage[@]}-1)) ]]; then
				echo "out of range - try again"
			else
				echo "Invalid Selection - Try Again"
			fi
		fi
	done

fi

if [[ $2 == "--down" ]]; then
	pkg="$1"
	loop=1
	aptpkg=$(apt list $pkg 2>/dev/null |grep $pkg |cut -d" " -f1 |cut -d"," -f1)
	[[ $aptpkg == "" ]] && echo "No valid package found" && exit 1
	echo "Package: $aptpkg"
	apt-get download "$aptpkg" 2>/dev/null
	debname=$(find . -name "$pkg*.deb")
	echo "Deb Name = $debname"
	datatar=$(ar t "$debname" |grep "data.tar")
	echo "data.tar = $datatar"

	if [[ ${datatar##*.} == "gz" ]];then 
		options="z"
	elif [[ ${datatar##*.} == "xz" ]];then
		options="J"
	else
		echo "data.tar is not a gz or xz archive. Exiting"
		exit 1
	fi
	manpage+=($(ar p $debname $datatar | tar t"$options" |grep "man/man" |grep -vE "\/$" |awk '{print $NF}'))
	while [[ $loop -eq 1 ]]; do
		if [[ -z $manpage ]];then
			echo "No man pages found in deb package - These are the contents of the $debname:"
			ar p "$debname" "$datatar" | tar t"$options"
			rm -f $debname
			exit 1
		else
			echo "man page found: ${#manpage[@]}"
			declare -p manpage |sed 's/declare -a manpage=(//g' |tr ' ' '\n' |sed 's/)$//g'
		fi
	
		if [[ ${#manpage[@]} -eq 1 ]]; then
			echo "One man page found - Display "
			ar p "$debname" "$datatar" | tar xO"$options" $manpage |man /dev/stdin #works ok
			loop=0
		else
			read -p "Select man pages to display by id or press a for all  - q to quit : " ms
			if [[ $ms == "a" ]]; then 
				echo "Display all"
				ar p "$debname" "$datatar" | tar xO"$options" ${manpage[@]} |man /dev/stdin #works ok
	#			loop=0
			elif [[ $ms == "q" ]]; then
				echo "exiting"
				loop=0
			elif [[ $ms -le $((${#manpage[@]}-1)) ]]; then
				echo "Display ${manpage[$ms]}"
				ar p "$debname" "$datatar" | tar xO"$options" ${manpage[$ms]} |man /dev/stdin #works ok
	#			loop=0
			elif [[ $ms -gt $((${#manpage[@]}-1)) ]]; then
				echo "out of range - try again"
			else
				echo "Invalid Selection - Try Again"
			fi
		fi
	done
	rm -f $debname
fi

if [[ $2 == "--debian" ]]; then
echo "grab man page by https://manpages.debian.org/cgi-bin/man.cgi and perform similar operation to dman ubuntu utility."
pkg="$1"
manpage=$(links -dump "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=Debian+8+jessie&format=html&locale=en")
found="Debian+8+jessie"
if [[ $manpage == *"no data found"* ]];then
	unset manpage
	echo "stable failed"
	manpage=$(links -dump "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=Debian+testing+stretch&format=html&locale=en")
	found="Debian+testing+stretch"
	if [[ $manpage == *"no data found"* ]];then
		unset manpage
		echo "testing failed"
		manpage=$(links -dump "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=Debian+unstable+sid&format=html&locale=en")
		found="Debian+unstable+sid"
		if [[ $manpage == *"no data found"* ]];then
			echo "unstable failed"
			echo "no man page available in debian online for package $pkg"
			found=""
			exit 1
		fi
	fi
fi
# As of January 2017 you can use the global page https://manpages.debian.org/jump?q=$1 which will jump you directly to corect section
# combine with awk to remove the first lines : 
# links -dump https://manpages.debian.org/jump?q=ngrep |awk "/Scroll to navigation/,0"

if [[ $2 == "--debian" && $3 == "--browser" ]]; then
gksu -u gv xdg-open "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=$found&format=html&locale=en" &
else
awk "/home | help | more information/,0" <<<"$manpage" |tail -n +2 |less
fi
# Also check http://manpages.ubuntu.com/manpages/xenial/en/man1/dman.1.html
# Also mind that debian manpages seems to fail in some pkgs, like netcat (either as pkg search or apropos search)
# Another great tool to investigate seems to be python debmans: https://pypi.python.org/pypi/debmans/1.0.0 
# https://debmans.readthedocs.io/en/latest/usage.html
fi

if [[ $2 == "--debcheck" ]]; then
echo "This is debian online manpages checker"
unset pk
unset pk1
#pk+=($(apt list "$1" |cut -d" " -f1 |cut -d"/" -f1))
pk1+=($(apt list "$1" |cut -d" " -f1 ))
for i in ${pk1[@]};do
	if [[ $(cut -d"/" -f2<<<"$i") == "experimental" ]];then
		echo "Package $i is experimental - test skipped since debian man pages online does not hold experimental man pages"
	else
		pk+=($(cut -d"/" -f1 <<<"$i"))
	fi
done
declare -p pk |sed 's/declare -a pk=(//g' |tr ' ' '\n' |sed 's/)$//g'
#sleep 5 && exit
for pkg in ${pk[@]};do
manpage=$(links -dump "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=Debian+8+jessie&format=html&locale=en")
if [[ $manpage == *"no data found"* ]];then
	unset manpage
#	echo "stable failed"
	manpage=$(links -dump "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=Debian+testing+stretch&format=html&locale=en")
	if [[ $manpage == *"no data found"* ]];then
		unset manpage
#		echo "testing failed"
		manpage=$(links -dump "https://manpages.debian.org/cgi-bin/man.cgi?query=$pkg&apropos=0&sektion=0&manpath=Debian+unstable+sid&format=html&locale=en")
		if [[ $manpage == *"no data found"* ]];then
#			echo "unstable failed"
			echo "no man page available in debian online for package $pkg" | tee -a debmanonline.log
#			exit 1
		fi
	fi
fi
done

fi


if [[ $2 == "--aptvsdeb" ]]; then
	while IFS=" " read -r _ _ _ _ _ _ _ _ _ pkg;do
		unset manpage
		unset aptresp aptpkg
		echo "Package in log: $pkg"
	#	pkg="$1"
		aptpkg=$(apt list $pkg 2>/dev/null |grep $pkg |cut -d" " -f1 |cut -d"," -f1)
		echo "Package in apt: $aptpkg"
		aptresp=$(apt-get --print-uris download $aptpkg 2>&1)
		echo "Apt Response: $aptresp"
		if [ "$aptresp" == *"Unable to locate package"* -o "$aptresp" == *"Handler silently"* ];then
			echo "Error. Either wrong package name or other error for $pkg. Raw output of apt:"
	#		apt-get --print-uris install $aptpkg
	#		exit 1
	#	fi
		else
			deb=$(grep "/$pkg" <<<"$aptresp" |cut -d" " -f1 |sed s/\'//g)
			echo "deb file : $deb"
			manpage+=($(curl -sL -o- $deb |dpkg -c /dev/stdin |grep "man/man" |grep -vE "\/$" |awk '{print $NF}'))
			if [[ -z $manpage ]];then
				echo "No man pages found in deb package for $pkg. These are the contents of the $deb:"
		#		curl -sL -o- $deb |dpkg -c /dev/stdin
			else
				echo "man page found: ${manpage[@]}"
#				declare -p manpage |sed s/"declare -a "//g
				echo "Package=$aptpkg, debmanpages=${manpage[@]}" >> debvsapt.log
			fi
		fi
	done <debmanonline.log
fi

if [[ $2 == "--aptcheck" ]]; then
		unset manpage aptresp aptpkg
		pkg="$1"
		aptpkg=$(apt list $pkg 2>/dev/null |grep $pkg |cut -d" " -f1 |cut -d"," -f1)
		echo "Package in apt: $aptpkg"
		aptresp=$(apt-get --print-uris download $aptpkg 2>&1)
		echo "Apt Response: $aptresp"
		if [ "$aptresp" == *"Unable to locate package"* -o "$aptresp" == *"Handler silently"* ];then
			echo "Error. Either wrong package name or other error for $pkg. Raw output of apt:"
			apt-get --print-uris install $aptpkg
			exit 1
	#	fi
		else
			deb=$(grep "/$pkg" <<<"$aptresp" |cut -d" " -f1 |sed s/\'//g)
			echo "deb file : $deb"
			manpage+=($(curl -sL -o- $deb |dpkg -c /dev/stdin |grep "man/man" |grep -vE "\/$" |awk '{print $NF}'))
			if [[ -z $manpage ]];then
				echo "No man pages found in deb package for $pkg. These are the contents of the $deb:"
				curl -sL -o- $deb |dpkg -c /dev/stdin
			else
				echo "man page found: ${manpage[@]}"
				declare -p manpage |sed 's/declare -a manpage=(//g' |tr ' ' '\n' |sed 's/)$//g'
			fi
		fi
fi



exit

# compare man pages:
# http://unix.stackexchange.com/questions/337884/how-to-view-differences-between-the-man-pages-for-different-versions-of-the-same
# diff -y -bw -W 150 <(links -dump "https://www.mankier.com/?q=grep" |less |fold -s -w 70) <(man grep |less |fold -s -w 70)
# diff_man() { diff -y <(man --manpath="/old/path/to/man" "$1") <(man "$1"); }
# Using process substitution = each process get a named fifo and it is treated as a file. 

:<<manpagealert
script to display all binaries missing man pages

Search for files who miss manpages
http://unix.stackexchange.com/questions/337619/is-there-a-way-to-find-installed-binary-packages-which-dont-have-manpages/337761#337761
Based on the source code of manpage_alert script, part of devscripts package, this solution works fine:
F=( "/bin/*" "/sbin/*" "/usr/bin/*" "/usr/sbin/*" "/usr/games/*" );for f in ${F[@]};do for ff in $f;do if ! mp=$(man -w -S 1:6:8 "${ff##*/}" 2>&1 >/dev/null);then echo "$mp" |grep -v "man 7 undocumented";fi;done;done

Actually each binary in folders bin,sbin,usr/bin and usr/sbin is called by man recursivelly.
-w switch prints man page location and -S defines particular section of man pages.
Redirections of 2>&1 and >/dev/null makes the man command to print nothing if there is a valid man page location.
If the command man complains about missing man page, then this message is printed.
actually even if you run man -w grep >/dev/null nothing will be printed but if you run man -w getweb >/dev/null then bellow error message is printed:
No manual entry for getweb - See 'man 7 undocumented' for help when manual pages are not available.

Error message is printed on stderr instead of stdout. As usuall error messages printed can not be stored in vars, unless you redirect stderr to stdout (2>&1)
Mind that even this command will print the err message, though that var $a is not echoed:
root@debi:# a=$(man -w getweb >/dev/null)
Which means that stderr will be printed to your screen no matter what, and $a will be a blanc var.

F=( "/bin/*" "/sbin/*" "/usr/bin/*" "/usr/sbin/*" "/usr/games/*" )
for f in ${F[@]};do 
  for ff in $f;do
    if ! mp=$(man -w -S 1:8:6 "${ff##*/}" 2>&1 >/dev/null);then 
       echo "$mp" |grep -v "man 7 undocumented" #man 7 undocumented is printed in a separate line.
    fi
  done
done

Oneliner:
F=( "/bin/*" "/sbin/*" "/usr/bin/*" "/usr/sbin/*" "/usr/games/*" );for f in ${F[@]};do for ff in $f;do if ! mp=$(man -w -S 1:6:8 "${ff##*/}" 2>&1 >/dev/null);then echo "$mp" |grep -v "man 7 undocumented";fi;done;done

manpagealert

ManPage Differences
In the new Debian Manpages as soon as you give the pkg name you are redirected to the man page directly of Jessie.
Works even with links , lynx and curl by CLI using "https://dyn.manpages.debian.org/jump?q=pkgname"
If you need to compare two different versions of the same pkg you can run :
diff -w -y <(links -dump "https://manpages.debian.org/jessie/xserver-xorg-input-synaptics/synclient.1.en.html") \
<(links -dump "https://manpages.debian.org/unstable/xserver-xorg-input-synaptics/synclient.1.en.html")

# 1. Curl Deb File and read the man page without downloading deb: 
# curl -sL -o- "http://httpredir.debian.org/debian/pool/main/a/avis/avis_1.2.2-4_all.deb" |dpkg-deb --fsys-tarfile /dev/stdin |tar -xO ./usr/share/man/man8/avisd.8.gz |man /dev/stdin
# mind that tar does not need -z or -J !
# curl -s=silent, -L = Locate link if moved , and -o- is -o = output to file, and dash indicates output to stdout 
# tar -x = xtract , -O = display extracted files on stdout instead of saving to file, -t = list files
# For testing , bellow commands display deb contents inside data archive of deb: 
# curl -sL -o- "http://httpredir.debian.org/debian/pool/main/a/avis/avis_1.2.2-4_all.deb" |dpkg-deb -c (/dev/stdin is not necessary)
# curl -sL -o- "http://httpredir.debian.org/debian/pool/main/a/avis/avis_1.2.2-4_all.deb" |dpkg-deb --fsys-tarfile /dev/stdin |tar -t
# dpkg -c <(curl -sL "http://httpredir.debian.org/debian/pool/main/a/avis/avis_1.2.2-4_all.deb") #also works ok
# Another complete example
# curl -sL -o- "http://httpredir.debian.org/debian/pool/main/a/axel/axel_2.11-1.1_amd64.deb" |dpkg-deb --fsys-tarfile /dev/stdin |tar -xO ./usr/share/man/man1/axel.1.gz |man /dev/stdin
# locate full deb address using apt --print-uris install axel |grep axel (to keep out all the dependency debs)
# even better to use apt --print-uris download axel. This will return the right package. install can return more debs (i.e try yade pkg)

# 2. Working example with deb downloading
# curl -sLO "http://httpredir.debian.org/debian/pool/main/a/avis/avis_1.2.2-4_all.deb" # curl -O saves the file in CWD
# ls -> avis_1.2.2-4_all.deb
# ar p avis_1.2.2-4_all.deb data.tar.xz | tar -xJO ./usr/share/man/man8/avisd.8.gz |man /dev/stdin #works ok
# tar -x = extract, -J = xz archive , -O output extracted file to stdout
# Tips: 
# This also works ok : ar -p `ls *.deb` data.tar.xz |unxz |tar -t . You can use unxz and gunzip to unzip xz and gz archives 
# tar -t is used just for listing . unxz -l claims that does not support stdin (?!)

# 3. Extract any compressed text file from downloaded deb:
# apt-get download netcat
# ar -p `ls *.deb` data.tar.xz |tar -Jt  #list files 
# ar -p `ls *.deb` data.tar.xz |tar -xJO ./usr/share/doc/netcat/changelog.Debian.gz |gunzip |cat (or less or whatever)
# or
# ar -p `ls *.deb` data.tar.xz |tar -xJO ./usr/share/doc/netcat/changelog.Debian.gz |man /dev/stdin
# man can operate as gunzip and cat on the same time, even if the file is a typical text file and not a man page.
# for some reason tar fails to unzip the last gz file (but gunzip works ok):
# ar -p `ls *.deb` data.tar.xz |tar -xJO ./usr/share/doc/netcat/changelog.Debian.gz |tar -xzO |cat
# if the file is not compressed you can just run tar -O (output to stdout = screen)
# ar -p `ls *.deb` data.tar.xz |tar -xJO ./usr/share/doc/netcat/copyright

# 4. Display contents of an not installed package without downloading
# apt-get --print-uris download apt-spy 2>&1 |cut -d" " -f1 |sed s/\'//g #this will isolate the full deb link
# dpkg -c <(curl -sL -o- $(apt-get --print-uris download apt-spy 2>&1 |cut -d" " -f1 |sed s/\'//g)) #this does the job
# though this fails to be registered an a alias due to the sed that tries to remove ' character from start/end.
# Alternative ${var: 1:-1} removes first and last char and now it works!
# alias lsaptonline='function __aso (){ tmpdeb=$(apt-get --print-uris download $1 2>&1 |cut -d" " -f1); tmpdeb=$(echo "${tmpdeb: 1:-1}");dpkg -c <(curl -sL -o- $tmpdeb); } ;__aso'



# 5. Resources:
# http://www.howtogeek.com/howto/uncategorized/linux-quicktip-downloading-and-un-tarring-in-one-step/
# http://man.cx/<pkghere>
# http://askubuntu.com/questions/92328/how-do-i-uncompress-a-tarball-that-uses-xz
# http://superuser.com/questions/82923/how-to-list-files-of-a-debian-package-without-install
#! https://www.g-loaded.eu/2008/01/28/how-to-extract-rpm-or-deb-packages/
# https://www.gnu.org/software/tar/manual/html_node/Writing-to-an-External-Program.html#SEC87
# https://www.cyberciti.biz/faq/howto-read-file-as-manpage-with-man-command/
# http://linux-tips.com/t/how-to-extract-deb-package/169
# http://unix.stackexchange.com/questions/61461/how-to-extract-specific-files-from-tar-gz
# https://blog.packagecloud.io/eng/2015/10/13/inspect-extract-contents-debian-packages/

# 5. Tips and Bugs
# apt --print-uris source (or download) agrep 
# Get file list of deb archive by web (debian package system / file tree)
# function deb_list () { curl -s $(lsb_release -si | sed -e 's Ubuntu http://packages.ubuntu.com/ ' -e 's Debian https://packages.debian.org/ ')/$(lsb_release -sc)/all/$1/filelist | sed -n -e '/<pre>/,/<\/pre>/p' | sed -e 's/<[^>]\+>//g' -e '/^$/d'; }
# man pages extension is .1 , .7, .8 depending on the man classification. 
# in deb files man page is xxxx.1.gz but man can handle it / decompress it directly without neet to tar -xz or gunzip /unxz first
# The --down or --apt solution (extract man from deb file) fails to detect / follow / display manpages that are in realiry symbolic links to other man pages inside the deb file.
# Reason of failure is that symlink points to something like ./usr/share/man/man1/correctmanpage.1.gz which will be only available if you fully extract the deb package.
# Instead of apt-get --print-uris download i also tried --print-uris install. But with install a lot of deb packages will be returned since a normal install operation will also install dependencies.
# As a result --print-uris download will return the one and only correct deb file for the package you provided.
# You can read any compressed page in your local system easily by using any of the following commands:
# man /usr/share/doc/bash/README.commands.gz #make use of the man capability to decompress and display man or even regular files
# zmore /usr/share/doc/bash/README.commands.gz |less #zmore is a default gz reader
# cat /usr/share/doc/bash/README.commands.gz |gunzip |less #again for some reason the tar -xzO is not working to display the file


# 6. See any sources tar file
# apt-get --print-uris source pkg
# find the orig or debian xz or gz archive - copy full http source link
# curl -sL -o- "source link" |tar -Jt (for xz) or -zt (for gz) -> You get a list of all files in archive. Copy the full path of the file you want
# curl -sL -o- "source link" |tar -xJO (for xz) or -xzO (for gz) file_path_inside_archive -> should print to stdout the file
# if the file you want is tar, then you need to further tar -x(z or J) or to unxz or to gunzip and then cut.
# curl -s = silent, -L = follow moved pages (case of httpredir) -o- = force output to stdout (-o = output , last - = stdout)
# tar -x = extract, -t=list files, -z=gz compressed, -J-xz compressed, -O force output to stdout.

# 7. Read man from sources 
# apt --print-uris source yaboot
# Usually returns orig.tar and debian.tar
# Locate the man page using tar -tz or -tJ (-t = list files of archive)
# curl -sL "http://httpredir.debian.org/debian/pool/non-free/a/agrep/agrep_4.17.orig.tar.gz" |tar -zt |egrep "agrep.[0-9]+$"
# >agrep-4.17/agrep.1
# curl -sL "http://debian.noc.ntua.gr/debian/pool/main/y/yaboot/yaboot_1.3.17.orig.tar.gz" |tar -xzO yaboot-1.3.17/man/yaboot.8 |man /dev/stdin
# -x = extract
# -z = gz archive. if tz archive, use -J
# -O = print to stdout
# man /dev/stdin : read man page from stdin

# Complete Job: 
# f=$(curl -sL "http://httpredir.debian.org/debian/pool/non-free/a/agrep/agrep_4.17.orig.tar.gz" |tar -zt |egrep "agrep.[0-9]+$")
# curl -sL "http://httpredir.debian.org/debian/pool/non-free/a/agrep/agrep_4.17.orig.tar.gz" |tar -xzO $f |man /dev/stdin

# Script based on source tar archives:
# script fails often (i.e bzr) since man pages was not found neither in original tar nor debian tar.

# In case you want to look in sources instead of the deb files, you could use  apt --print-uris source $pkg 2>&1 |grep "orig" |cut -d" " -f1 |sed s/\'//g) #isolate the link, remove ' in front/end of http add
# Sources often include a file with name orig (=original) or with name debian = debian specific, that can be catched with s wapt --print-uris source $pkg 2>&1 |grep "debian.tar" |cut -d" " -f1 |sed s/\'//g)
# This worked before to switch to deb file analysis:
	#if [[ ${origsrc##*.} == "gz" ]];then #check last chars after the last dot
		#f=$(curl -sL "$src" |tar -zt |grep -P "$pkg\.[0-9]$") #list archive files, find the man page
		#if [[ -z $f ]];then #if man page not found in original source
			#if [[ ${debsrc##*.} == "xz" ]];then #check debian extension
				#echo "this is a xz archive"
				#echo "Debian source is : $srcdeb"
				#fdeb=$(curl -sL "$srcdeb" |tar -Jt |grep -P "$pkg.\.[0-9]$") #look for manual in debian source
				#echo "Manual Found on debian.tar: $fdeb"
			#fi
		#else
			#echo "Manual Found on original source: $f"
		#fi

	#read -p "press any key to read man"
	
		#if [[ -z $f ]];then
			#curl -sL "$srcdeb" |tar -xJO $fdeb |man /dev/stdin
		#else
			#curl -sL "$src" |tar -xzO $f |man /dev/stdin
		#fi
