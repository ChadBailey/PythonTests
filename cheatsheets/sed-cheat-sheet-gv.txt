.\" Manpage for bash cheats.
.\" Contact vivek@nixcraft.net.in to correct errors or typos.
.TH man 8 "06 May 2010" "1.0" "nuseradd man page"

SED:BASICS: CHEAT SHEET by gv
http://sed.sourceforge.net/grabbag/tutorials/
http://sed.sourceforge.net/sed1line.txt
http://stackoverflow.com/questions/83329/how-can-i-extract-a-range-of-lines-from-a-text-file-on-unix
http://www.theunixschool.com/2014/08/sed-examples-remove-delete-chars-from-line-file.html
http://www.theunixschool.com/2012/06/sed-25-examples-to-delete-line-or.html

-n: not printing/quiet. If missing the input is printed.
-e: sed expression follows
-i: infile edit
's/..' : replace
'.../p' : print (force print when -n is used). some times requires space ('/.../ p'). Also !p for not print. Combine with -n to disable global printing and print specific lines/patterns that /p applies.
'..../d' : delete . Also !d for not delete. Combine /d with missing -n to see the input with the deletions.
'N': N command ReadS next line into the pattern space.

Read Sed Online Cheat Sheets in terminal : curl -sL -o- http://sed.sourceforge.net/sed1line.txt |less

#------------------------------------------------------------------------------------------------------------------
SED: CHEAT SHEET TXT 2 MANPAGE FORMATTING
http://technicalprose.blogspot.gr/2011/06/how-to-write-unix-man-page.html

Read this cheat file with man pages:
man --nh --nj <(sed 's/^BASH:/.SH BASH:/g; s/^$/---/g;G' cheatsheets/bash*gv.txt |sed 's/^$/\.br/g; s/^---$//g')
man --nh --nj <(sed 's/^SED:/.SH SED:/g; s/^$/---/g;G' cheatsheets/sed*gv.txt |sed 's/^$/\.br/g; s/^---$//g')

man ignores normal line feeds at end of lines ($), but empty lines in form ^$ are recognized and displayed
Line feeds in man pages can be done by inserting .br between two lines.
Man sections start with .SH. 

First sed  finds capitalized SED headers in file and insert .SH in front (i.e SED:BASICS becomes .SH SED:BASICS)
Then we get the existing empty lines (^$) of original file and replace them with a temp pattern ---
Then using sed G option we double all lines = double file spacing => a new line is inserted after every line in file

This sed creates a new stream which is then piped to a new sed.
New sed adds .br in every empty line (created by G action before) except the old new lines who contain --- and do not match ^$ pattern
New sed removes then the temp pattern --- from the old empty lines and old empty lines are restored.

So at the end of the day we have a man page compatible file like
#.SH SED:BASICS
#Line1
#.br
#Line2
#.br
#<empty line>
#.br
#Line3
#.br
#Line4

Man displays the file as it would display in any editor , in the old file classic txt format:
#SED:BASHICS (in bold!)
#Line1
#Line2

#Line3
#Line4

PS: More consequitve .br in a series of lines are ignored and got intepreted by man as a single line feed.

PS: man options --nj = not auto justified , --nh = not auto break at hyphen

Alternativelly, if you don't mind to read the file with one empty line after each line , this also works fine:
man --nh --nj <(sed 's/^SED:/.SH SED:/g; G' cheatsheets/sed*gv.txt)
This works because empty lines are recognized and displayed by man.

Another alternative is to insert a new paragraph symbol = .LP in old empty lines - has the same effect:
man --nh --nj <(sed 's/^BASH:/.SH BASH:/g; s/^$/\.LP/g;G' cheatsheets/bash*gv.txt |sed 's/^$/\.br/g')
existing empty lines get .LP , created empty lines get .br 

#------------------------------------------------------------------------------------------------------------------
SED:SEPARATORS 
All tutos describe operations with /. Slash can be replaced with any character (i.e ! or #) to make reading easier.

Tricky sed usage if strings replace strange chars like slashes:
a="https://www.google.gr";echo " log <sitepath />/<sitename />/platform_dir/logs/nginxerror.log" | sed -r "s#<sitepath /># $a #"  --> log  https://www.google.gr /<sitename />/platform_dir/logs/nginxerror.log
Trick is that you can seperate actions with any char and not only /. If sed separators are left / (default) and patterns also include / then you need to escape pattern / (using \/) and the sed command becomes a mesh.

SED Use external variable (i.e $line,$text,etc - defined before sed)
You just need to double quote the whole sed expression instead of single quotes.
#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:PRINT FIND AND PRINT ENTRIES FROM CHEATSHEETS
sed -n '/SED:PRINT.*line.*/,/#-----/p' ./cheatsheets/sed*gv*.txt
sed -n '/JOIN/,/#----/p' ./cheatsheets/*
#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:PRINT FROM LINE X to LINE Y 
sed -n '8,12p'
sed -n '16224,16482p;16483q' filename
mind the 16483q command. q instructs sed to quit. Without q sed will keep scanning up to EOF.
To do that with variables: $ sed -n "$FL,$LL p" file.txt
#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:PRINT FROM WORD1 TO WORD2
sed -n '/word1/,/word2/p' 
sed -n '/WORD1/,/WORD2/ p' /path/to/file # this prints all the lines between word1 and word2 (1st match - next matches of word2 ignored)
awk alternative: awk '/Tatty Error/,/suck/' a.txt
you can get easy line numbering if you pipe to "cat -n" or to "nl" in the penalty of usings an extra pipe = more resources for that.
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT FROM WORD/LINE UP TO EOF (last \n new line ).
Remember that $ represents "last"-end of line in regex
apt show xfce4-wmdock* |sed -n '/Description/,/$\/n/p'

You can do the same starting from a line up to eof. 
Also this works sed -n '/matched/,$p' file , wherw matched can be a line number or a string
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT FROM REGEX UPTO EOF
sed -n '/regexp/,$p'
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT FROM 1ST LINE UP TO PATTERN/WORD:
$ sed -n '1,/WORD/p' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT lines match regex 
sed -n '/regexp/p' #grep emulation
sed -n '/regexp/!p' #grep -v
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT lines before /after a regexp, but not the line containing the regexp
sed -n '/regexp/{g;1!p;};h' #the line before match
sed -n '/regexp/{n;p;}' 	#the line after match
#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:REPLACE (s/original/replaced/)

sed  -n 's/Tatty Error/suck/p' a.txt # This one replaces Tatty Error with word suck and prints the whole changed line
echo "192.168.1.0/24" | sed  -n 's/0.24/2/p' 
More Sed replace acc to http://unix.stackexchange.com/questions/112023/how-can-i-replace-a-string-in-a-files
#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE foo with bar only if there is a baz later on the same line:
sed -i 's/foo\(.*baz\)/bar\1/' file #mind the -i switch which writes the replacement in file (-i = inplace).
#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE Multiple replace operations: replace with different strings
You can combine sed commands: sed -i 's/foo/bar/g; s/baz/zab/g; s/Alice/Joan/g' file #/g means global = all matches in file
#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE any of foo, bar or baz with foobar : sed -Ei 's/foo|bar|baz/foobar/g' file
Sed replace a string in a line with pattern: sed -e '/^400/ s/,\{10\}$//' -e '/^300/ s/,\{5\}$//' -e '/^210/ s/,\{2\}$//'
above sed removes 10chars from end in line starting with 400, removes 5 chars at line starting 300 etc.
#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE first occurence of a pattern (as) in every line with an increasing number 
while read line;do sed 's/as/'"$(( ++count ))"'/1' <<< "$line";done < source_file > target_file

#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE More Text Replace with sed
Consider file containing:
ltm node /test/10.90.0.1 {
   address 10.90.0.1
}

1. Lets suppose you want to add at the end of address %200
sed '/address/ s/$/%200/' a.txt
s = replace, $= end of line

Alternatives
str="address 10.90.0.1";newstr=$(awk -F"." '{print $1"."$2"."$3"."$4"%200"}'<<<$str);echo $newstr 
awk '/address/ && sub("$","%200") || 1' file.txt
#

2. Lets suppose you want to replace the last digit with .20
sed '/address/ s/.[0-9]*$/.20/' a.txt
.[0-9]*$ = regex = starts with dot, contains numbers in range 0-9, multiple numbers (*) and then EOL ($)
alternatives
str="address 10.90.0.1";newstr=$(awk -F"." '{print $1"."$2"."$3".20"}'<<<$str);echo $newstr

#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE text inside curly
This is {
the multiline
text file }
that wants
{ to be
changed
} anyway.

Output:
This is 
that wants
 anyway
 
Command:
$ sed ':again;$!N;$!b again; s/{[^}]*}//g' file
:again;$!N;$!b again; #This reads the whole file into the pattern space.
:again #is a label.  N reads in the next line.  
$!b again #branches back to the again label on the condition that this is not the last line.

s/{[^}]*}//g #This removes all expressions in braces.

Alternative:
sed '/{/{:1;N;s/{.*}//;T1}' multiline.file
started since line with { and get the next line (N) until substitution ({}) can be made 
( T means return to mark made by : if substitution isnt made)

http://unix.stackexchange.com/questions/71670/add-in-begining-to-selected-lines-in-file?rq=1
	
#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:REPLACE dash in string
String: #  1  2016-05-31-1003-57S._BKSR_003_CM6
$ sed 's/..$/-\0/g' <(cut -d- -f1-4 <(cut -d" " -f5- file.txt)) #use >newfile at the end to send the results to a new file
Output : 2016-05-31-10-03
alternatives:
$ cut --output-delimiter='-' -c7-19,20-21 file.txt
$ while IFS= read -r line;do line="${line:6:13}-${line:14:2}";echo $line;done<file.txt
$ awk '{print substr($3,0,13)"-"substr($3,14,2)}' file.txt

#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:REPLACE STRING AFTER PATTERN MATCH
You can combine sed words search (/word1/,/word2/) and then you can continue on the same line to perform replace with usual s/old/new/
Input Example:
priority = 0
host = True

[shovel]
group = 
enabled = 0

Target : Change value of shovel enabled (from 0 to 1)

Command: sed '/\[shovel\]/,/^$/ s/enabled = 0/enabled = 1/' file
First part=/\[shovel\]/,/^$/ : from word [shovel] up to the next empty line (empty lines contain just start(^) and end ($) chars)
Second part=s/enabled = 0/enabled = 1/ : usual sed replace in form s/old/new

#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:REPLACE Another example of replace after match:
sed '/(/,/)/s/line/newline/g' #replaces line0-1-2-etc with newline0-1-2-etc in a file where first line and last line are in format (line0 ... up to lineX)
split to understand: the fine part is /(/,/)/ = /(/ , /)/
insteaf of 'p' at the end we use s/old/new/ for replace.

#------------#-------------##------------#-------------##------------#-------------##------------#-------------#
SED:EXAMPLES BY http://www.theunixschool.com/2014/08/sed-examples-remove-delete-chars-from-line-file.html
#------------#-------------##------------#-------------##------------#-------------##------------#-------------#

SED:DELETE To remove 1st character in every line:
$ sed 's/^.//' file or sed  's/.//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove last character of every line : 
$ sed 's/.$//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove the 1st and last character of every line in the same command: 
$ sed 's/.//;s/.$//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove first character only if it is a specific character: 
$ sed 's/^F//' file #Removes Lines starting with F
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove last character only if it is a specific character: 
$ sed 's/x$//' file #removes last character if is x
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove 1st 3 characters of every line: 
$ sed 's/...//' file #OR# $ sed -r 's/.{3}//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove last n characters of every line: 
$ sed -r 's/.{3}$//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove everything except the 1st n characters in every line: 
$ sed -r 's/(.{3}).*/\1/' file
#  .* -> matches any number of characters.
# first 3 characters matched are grouped using parantheses. 
# In the replacement, by having \1 only the group is retained, leaving out the remaining part.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE  Similarly , to remove everything except the last n characters in a file: 
$ sed -r 's/.*(.{3})/\1/' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove multiple characters present in a file: 
$ sed 's/[aoe]//g' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove a pattern  : 
$ sed 's/lari//g' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To delete only nth occurrence of a character in every line: 
$ sed 's/u//2' file #replaces two u and stops. /g replaces all . Leave it blank replace only the first found.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To delete everything in a line followed by a character: 
$ sed 's/a.*//' file #In Word RedHat this Returns RedH
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove all digits present in every line of a file: 
$ sed 's/[0-9]//g' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove all lower case alphabets present in every line: 
$ sed 's/[a-z]//g' file #in word Linux this returns L
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove all alpha-numeric characters present in every line: 
$ sed 's/[a-zA-Z0-9]//g' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove a character irrespective of the case: 
$ sed 's/[uU]//g' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print first / last line of the file: 
$ sed -n '1p' file  / sed -n '$p' file 
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print lines which does not X / do contain 'ux':
$ sed -n '/X/!p' file / $ sed -n '/[ux]/p' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print lines which end with 'x' or 'X' / Beginning with 'A' or 'L'
$ sed -n '/[xX]$/p' file   /   sed -n '/^A\|^L/p' file
Some sed version does not accept | (or). Use two patterns instead.
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print every alternate line (skip one line):
$ sed  'n;d' file
n command prints the current line, and immediately reads the next line into pattern space. d command deletes the line present in pattern space. In this way, alternate lines get printed.

Similarly sed  'n;n;N;d' file print every two lines
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print lines ending with 'X' within a range of lines:
$ sed -n '/Unix/,${/X$/p;}' file

The range of lines being chosen are starting from the line containing the pattern 'Unix' till the end of the file($). The commands present within the braces are applied only for this range of lines. 
Within this group, only the lines ending with 'x' are printed. 
Refer this to know how to print a range of lines using sed from example 5 onwards.
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print range of lines excluding the starting and ending line of the range:
$ sed -n '/Solaris/,/HPUX/{//!p;}' file
The range of lines chosen is from 'Solaris' to 'HPUX'. 
The action within the braces is applied only for this range of lines. 
If no pattern is provided in pattern matching (//), the last matched pattern is considered. 
For eg, when the line containing the pattern 'Solaris' matches the range of lines and gets inside the curly braches, since no pattern is present, the last pattern (solaris) is matched. 
Since this matching is true, it is not printed(!p), and the same becomes true for the last line in the group as well.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete a particular line : 
$ sed '1d' file OR  $ sed '3d' file OR $ sed '$d' file (last line) OR sed '2,4d' file (range) OR sed '1d;$d' file (first and last line)
Tip: replace d with !d to invert the action = delete lines other than those with !d.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete all lines beginning with 'L'  /OR/ ending with 'x' character: 
$ sed '/^L/d' file /OR/ sed '/x$/d' file /OR/ sed '/[xX]$/d' file (both x and X) 
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete all blank lines in the file
$ sed '/^$/d' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete all lines which are empty or which contains just some blank spaces:
$ sed '/^ *$/d' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the lines containing the pattern 'Unix'.
$ sed '/Unix/d' file #Use !d to delete line NOT containing the pattern Unix.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the lines containing the pattern 'Unix' OR 'Linux':
$ sed '/Unix\|Linux/d' file #In some sed OR | is not working - use two expressions (not a pipe)
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the lines starting from the 1st line till encountering the pattern 'Linux':
$ sed '1,/Linux/d' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the lines starting from the pattern 'Linux' till the last line:
$ sed '/Linux/,$d' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the last line ONLY if it contains the pattern 'AIX':
$ sed '${/AIX/d;}' file /OR/ sed '${/AIX\|HPUX/d;}' file (two patterns with or)
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the lines containing the pattern 'Solaris' only if it is present in the lines from 1 to 4.
$ sed '1,4{/Solaris/d;}' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the line containing the pattern 'Unix' and also the next line:
$ sed '/Unix/{N;d;}' file
N command reads the next line in the pattern space. d deletes the entire pattern space which contains the current and the next line.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete only the next line containing the pattern 'Unix', not the very line:
$ sed '/Unix/{N;s/\n.*//;}' file
with s/ we delete from the newline character till the end, which effective deletes the next line after the line containing the pattern Unix.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the line containing the pattern 'Linux', also the line before the pattern:
$ sed -n '/Linux/{s/.*//;x;d;};x;p;${x;p;}' file | sed '/^$/d'

In order to delete the line prior to the pattern,we store every line in a buffer called as hold space. 
Whenever the pattern matches, we delete the content present in both, the pattern space which contains the current line, the hold space which contains the previous line.
'x;p;' ; This gets executed for every line. x exchanges the content of pattern space with hold space. p prints the pattern space. 
As a result, every time, the current line goes to hold space, and the previous line comes to pattern space and gets printed. 
When the pattern /Linux/ matches, we empty(s/.*//) the pattern space, and exchange(x) with the hold space(as a result of which the hold space becomes empty) and delete(d) the pattern space which contains the previous line. 

And hence, the current and the previous line gets deleted on encountering the pattern Linux. The ${x;p;} is to print the last line which will remain in the hold space if left.
The second part of sed is to remove the empty lines created by the first sed command
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete only the line prior to the line containing the pattern  'Linux', not the very line:
$  sed -n '/Linux/{x;d;};1h;1!{x;p;};${x;p;}' file

This is almost same as the last one with few changes. On encountering the pattern /Linux/, we exchange(x) and delete(d). As a result of exchange, the current line remains in hold space, and the previous line which came into pattern space got deleted.
1h;1!{x;p;} -  1h is to move the current line to hold space only if it first line. Exchange and print for all the other lines. This could easily have been simply: x;p . The drawback is it gives an empty line at the beginning because during the first exchange between the pattern space and hold space, a new line comes to pattern space since hold space is empty.
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete only the line prior to the line containing the pattern  'Linux', not the very line:
$  sed -n '/Linux/{x;d;};1h;1!{x;p;};${x;p;}' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE Delete the line containing the pattern 'Linux', the line before, the line after:
$ sed -n '/Linux/{N;s/.*//;x;d;};x;p;${x;p;}' file | sed '/^$/d'
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To remove the 1st field or column (comma separated text):
$ sed 's/[^,]*,//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT To print only the last field, OR remove all fields except the last field:
$ sed 's/.*,//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT To print only the 1st field:
$ sed 's/,.*//' file
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE To delete the 2nd field /OR/ To print only the second field
$ sed 's/,[^,]*,/,/' file  /OR/  sed 's/[^,]*,\([^,]*\).*/\1/' file
#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE To insert a new column at the end(last column) :
$ sed 's/.*/&,A/' file
The regex (.*) matches the entire line and replacing it with the line itself (&) and the new field = letter A
#-----------------------------------------------------------------------------------------------------------------------
SED:REPLACE To insert a new column in the beginning(1st column):
$ sed 's/.*/A,&/' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT To print the entire file contents:
$ sed '' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT print /delete only the line containing 'Gmail'. In other words, to simulate the grep or grep -v command:
$ sed '/Gmail/p' file - For delete use /d instead of /p
#-----------------------------------------------------------------------------------------------------------------------
SED:DELETE delete the first line of the file:
$ sed '1d' file
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT Print lines till you encounter a specific pattern, say till 'Yahoo' is encountered.
$ sed  '/Yahoo/q' file  #q = quit if pattern / expression matched. Without -n option in sed, lines up to Yahoo are printed (default action of sed is to print).
#-----------------------------------------------------------------------------------------------------------------------
SED:PRINT To print the first 3 lines, or from lines 1 through 3:
$ sed -n '1,3p' file #Alternative : sed '3q' file
#-----------------------------------------------------------------------------------------------------------------------
SED:INSERT TEXT TO THE END OF FILE
sed -i -e "\$aTEXTTOEND" <filename>
OR
sed '$s/$/texttoend/'
Tip: if instead $a you use i.e 4a text will append to 4th line
#-----------------------------------------------------------------------------------------------------------------------
SED:INSERT TEXT TO THE START OF FILE
The command inserts a tag to the beginning of a file:

sed -i "1s/^/<?php /" file
#-----------------------------------------------------------------------------------------------------------------------
