SED:BASICS: CHEAT SHEET by gv
http://sed.sourceforge.net/grabbag/tutorials/
http://sed.sourceforge.net/sed1line.txt
http://stackoverflow.com/questions/83329/how-can-i-extract-a-range-of-lines-from-a-text-file-on-unix
http://www.theunixschool.com/2014/08/sed-examples-remove-delete-chars-from-line-file.html
http://www.theunixschool.com/2012/06/sed-25-examples-to-delete-line-or.html
man sed and info sed. Especially info has tons of examples and special cases.

-n: not printing/quiet. If missing the input is printed.
-e: sed expression follows
-i: infile edit
's/..' : replace
'.../p' : print (force print when -n is used). some times requires space ('/.../ p'). Also !p for not print. Combine with -n to disable global printing and print specific lines/patterns that /p applies.
'..../d' : delete . Also !d for not delete. Combine /d with missing -n to see the input with the deletions.
'N': N command ReadS next line into the pattern space.

Read Sed Online Cheat Sheets in terminal : curl -sL -o- http://sed.sourceforge.net/sed1line.txt |less

For a detailed explanation of BRE and ERE (basic and extended regular expressions) see info sed at the relevant chapter.

##SEPARATORS 
All tutos describe operations with /. Slash can be replaced with any character (i.e ! or #) to make reading easier.
Actually is not only a visual help but can become quite a functional trick.
If the search terms, regexs contain chars same as delimiter, you need to escape them.
But if you apply a different delimiter you can avoid the escaping.

For example this tricky sed usage replace strange chars like slashes without the need to escape slashes since the delimiter is different.
a="https://www.google.gr";echo " log <sitepath />/<sitename />/platform_dir/logs/nginxerror.log" | sed -r "s#<sitepath /># $a #"  --> log  https://www.google.gr /<sitename />/platform_dir/logs/nginxerror.log

##info sed notice:
info advises that other chars like % or ; etc when used as delimiters , first delimiter should start with \.
That means that sed '/word/p' ==> sed '\%word%p'

##SED Use external variable (i.e $line,$text,etc - defined before sed)
You just need to double quote the whole sed expression instead of single quotes.
Alternativelly you can use double quotes only at var but you need also to apply single quotes outside the double quotes.
i.e sed 's/'"$a"'/something/g' file

##Modifiers (see also info sed)
/REGEXP/I : I is for case insestive. Don't confuse with i which is operation insert
/REGEXP/M : Multiline mode - cause match of regexp including new lines before/after regexp - ^$ not operating - use \` and \' instead


SED:CHEAT SHEET TXT 2 MANPAGE FORMATTING
##Read this cheat file with man pages:
http://technicalprose.blogspot.gr/2011/06/how-to-write-unix-man-page.html
man formatting: man 7 man
groff programming: http://web.cecs.pdx.edu/~trent/gnu/groff/groff.html#IDX123
man pages making: https://liw.fi/manpages/
https://linux.die.net/man/1/help2man

##Working Command:
man --nj <(h=".TH man 1 2017 1.0 cheats page";sed "1i $h" cheatsheets/utils*gv.txt |sed 's/^UTILS:/.SH UTILS:/g; s/^$/\.LP/g; s/^##/\.SS /g; s/\\/\\e/g;G' |sed 's/^$/\.br/g')
You can also combine with --nh 
PS: man options --nj = not auto justified , --nh = not auto break words with hyphen on line changes.

##man and groff/troff require special handling.
man ignores normal line feeds at end of lines ($); empty lines (^$) are recognized and displayed
Line feeds in man pages can be done by inserting .br between two lines.
More .br in series of lines are ignored by man and got intepreted as a single line feed - not multiple new lines.
Man pages should start with a .TH line
Man sections / header start with .SH. 
Subsection start with .SS. Alternativelly you can use .B to make this line bold. .B follows text identation - .SS has it's own idents.
The backslash \ works as escape in groff, so you need to escape the backslash with \e (or \\ can also work)
The example tr -d '\n' will become tr -d '\en' with \e escaping, or will become tr -d '\\n' with \\ escaping.

First sed  inserts a ".TH" as very first line in stream.
Then sed replaces capitalized  headers in file (format i.e BASH:) and insert .SH in front of them (i.e SED:BASICS becomes .SH SED:BASICS)
Then sed inserts .LP in the existing empty lines (^$) of original file. This forces man to preserve the empty line and consider the following lines as a new paragraph.
(previously i was injecting a temp pattern like ---- that was removed afterwards)
Then sed inserts a .SS in front of all the lines that start with ## and are considered as subheaders.
Then sed replaces existing backslashes in txt file with \e. So a description/example like \n will become \en and will be displayed like \n
and replace them with a temp pattern ---
Then using sed G option we double all lines = double file spacing => a new line is inserted after every line in file

This sed creates a new stream which is then piped to a new sed.
New sed adds .br in every empty line that was created by G action before. Old new lines contain .LP (or --- in prev versions) and are not affected. 

So at the end of the day we have a man page compatible file like
#.SH SED:BASICS
#Line1: tr -d '\en'
#.br
#Line2
#.br
#.LP
#.br
#Line3
#.br
#Line4

Man displays the file as it would display in any editor , in the old file classic txt format:
#SED:BASHICS (in bold!)
#Line1: tr -d '\n'
#Line2
<empty line>
#Line3
#Line4

##Light Conversions
man --nh --nj <(sed 's/^SED:/.SH SED:/g; G' cheatsheets/sed*gv.txt)
man --nh --nj <(sed 's/^BASH:/.SH BASH:/g; s/^$/---/g;G' cheatsheets/bash*gv.txt |sed 's/^$/\.br/g; s/^---$//g')
man --nh --nj <(sed 's/^SED:/.SH SED:/g; s/^$/---/g;G' cheatsheets/sed*gv.txt |sed 's/^$/\.br/g; s/^---$//g')

SED:PRINT 
##FIND AND PRINT ENTRIES FROM CHEATSHEETS TXT FILES
sed -n '/SED:PRINT.*line.*/,/# -----/p' ./cheatsheets/sed*gv*.txt
sed -n '/JOIN/,/# ----/p' ./cheatsheets/*

##Print range
(a) sed -n '/regexp/p' #grep emulation - Print lines matching regex
(b) sed -n '8,12p' #print from line 8 up to 12
(c) sed -n '16224,16482p;16483q' filename #mind the 16483q command. q instructs sed to quit. Without q sed will keep scanning up to EOF.
    alternative with variables: sed -n "$FL,$LL p" file.txt
(d) sed -n '8,/pattern/p' #from 8th line up to pattern
(e) sed -n '/word1/,/word2/p' #from word 1 up to first match of word2. Some times a space is required before p (/ p)
    awk alternative: awk '/Tatty Error/,/suck/' a.txt
(f) sed -n '/pattern/,$p' file #from pattern "Description" up to EOF = last \n. Instead of pattern you can use a starting line i.e '10,$p'
    alternative: sed -n '/Description/,/$\/n/p'  - match up to last \n
(g) sed -n '1,/WORD/p' file # from 1st line up to pattern word
(h) sed -n '/regexp/!p' #grep -v match lines NOT containing regexp
(i) sed -n '1,/regexp/!p' #exclude line 1 up to regexp and print the rest
(k) sed -n '/regexp/,$!p' a.txt  #exclude from regexp up to EOF and print the rest.
(l) sed -n 'ADDR1,+N'  #Matches ADDR1 and N lines following ADDR1, i.e sed -n '6,+2p'. ADDR1 can be a line number or a pattern

##Print lines before /after a regexp, but not the line containing the regexp
sed -n '/regexp/{g;1!p;};h' #the line before match
sed -n '/regexp/{n;p;}' 	#the line after match

SED:REPLACE (s/original/replaced/)
Also see: http://unix.stackexchange.com/questions/112023/how-can-i-replace-a-string-in-a-files

## This one replaces Tatty Error with word suck and prints the whole changed line
sed  -n 's/Tatty Error/suck/p' a.txt 
echo "192.168.1.0/24" | sed  -n 's/0.24/2/p' 

##Replace foo with bar only if there is a baz later on the same line:
sed -i 's/foo\(.*baz\)/bar\1/' file ##mind the -i switch which writes the replacement in file (-i = inplace).

##Replace Multiple replace operations: replace with different strings
You can combine sed commands: sed -i 's/foo/bar/g; s/baz/zab/g; s/Alice/Joan/g' file ##/g means global = all matches in file

##Replace any of foo, bar or baz with foobar
sed -Ei 's/foo|bar|baz/foobar/g' file

##Sed replace a string in a line with pattern: 
sed -e '/^400/ s/,\{10\}$//' -e '/^300/ s/,\{5\}$//' -e '/^210/ s/,\{2\}$//'
above sed removes 10chars from end in line starting with 400, removes 5 chars at line starting 300 etc.

##Replace first occurence of a pattern (as) in every line with an increasing number 
while read line;do sed 's/as/'"$(( ++count ))"'/1' <<< "$line";done < source_file > target_file

##Replace chars with regex
See info sed - Regular Expressions
echo "abc %-= def." | sed 's/\b/X/g' ---> XabcX %-= XdefX. #\b = word bountary - \B all but not word boundary
echo "abc %-= def." | sed 's/\b/"/g' ---> "abc" %-= "def". #Insert double quotes with \b word bountary
echo "abc %-= def." | sed 's/\w/X/g' ---> XXX %-= XXX.   #\w = word match - \W all but not word
echo "abc %-= def." | sed 's/\s/X/g' ---> abcX%-=Xdef.   #\s = all whitespace - \S all but not whitespace
echo "abc %-= def." | sed 's/\</X/g' ---> Xabc %-= Xdef. #match beginning of word. Use \> to match end of word
sed -E -n '/^(.)o\1$/p' ---> matches words starting with any letter , followed by letter o - followed by a letter same as first (\1)
sed -E -n '/^(.)(.)(.)\3\2\1$/p' --> searches for 6-letter palindromes: first 3 letters are 3 subexpressions, followed by 3 back-references in reverse order

##Replace special chars like backslash and single quotes
Backslash has a special meaning = escape.
If your file/stream contains backslashes is a kind of pain to correctly match them and replace them.
More pain if the old text/new text also contain backslashes.
Similar story for single quotes.
In  such cases is quite usefull to refer to the special chars with their hex ascii value.
Back slash is \x5c and single quote is \x27

See for example this alias that makes single quotes escaping with backslashes:
alias esc_single_quotes='sed "s|\x27|\x5c\x5c\x27|g"'
echo "this is 'something'" ---> this is 'something' #text is containing single quotes.
echo "this is 'something'" |esc_single_quotes ---> this is \'something\' #replaced text should contain backslash + single quote in order to be sent to other apps with single quotes escaped.

##Text Replace more examples 
Consider file containing:
ltm node /test/10.90.0.1 {
   address 10.90.0.1
}

1. Lets suppose you want to add at the end of address %200
sed '/address/ s/$/%200/' a.txt
s = replace, $= end of line

Alternatives
str="address 10.90.0.1";newstr=$(awk -F"." '{print $1"."$2"."$3"."$4"%200"}'<<<$str);echo $newstr 
awk '/address/ && sub("$","%200") || 1' file.txt

2. Lets suppose you want to replace the last digit with .20
sed '/address/ s/.[0-9]*$/.20/' a.txt
.[0-9]*$ = regex = starts with dot, contains numbers in range 0-9, multiple numbers (*) and then EOL ($)
alternatives
str="address 10.90.0.1";newstr=$(awk -F"." '{print $1"."$2"."$3".20"}'<<<$str);echo $newstr


3. Delete text inside curly
This is {
the multiline
text file }
that wants
{ to be
changed
} anyway.

Output:
This is 
that wants
 anyway
 
Command:
$ sed ':again;$!N;$!b again; s/{[^}]*}//g' file
:again;$!N;$!b again; #This reads the whole file into the pattern space.
:again #is a label.  N reads in the next line.  
$!b again #branches back to the again label on the condition that this is not the last line.

s/{[^}]*}//g #This removes all expressions in braces.

Alternative:
sed '/{/{:1;N;s/{.*}//;T1}' multiline.file
started since line with { and get the next line (N) until substitution ({}) can be made 
( T means return to mark made by : if substitution isnt made)

http://unix.stackexchange.com/questions/71670/add-in-begining-to-selected-lines-in-file?rq=1


4.Replace dash in string
String: #  1  2016-05-31-1003-57S._BKSR_003_CM6
$ sed 's/..$/-\0/g' <(cut -d- -f1-4 <(cut -d" " -f5- file.txt)) #use >newfile at the end to send the results to a new file
Output : 2016-05-31-10-03

Alternatives:
$ cut --output-delimiter='-' -c7-19,20-21 file.txt
$ while IFS= read -r line;do line="${line:6:13}-${line:14:2}";echo $line;done<file.txt
$ awk '{print substr($3,0,13)"-"substr($3,14,2)}' file.txt

## REPLACE STRING AFTER PATTERN MATCH
You can combine sed words search (/word1/,/word2/) and then you can continue on the same line to perform replace with usual s/old/new/
Input Example:
priority = 0
host = True

[shovel]
group = 
enabled = 0

Target : Change value of shovel enabled (from 0 to 1)

Command: sed '/\[shovel\]/,/^$/ s/enabled = 0/enabled = 1/' file
First part=/\[shovel\]/,/^$/ : from word [shovel] up to the next empty line (empty lines contain just start(^) and end ($) chars)
Second part=s/enabled = 0/enabled = 1/ : usual sed replace in form s/old/new

##Another example of replace after match:
sed '/(/,/)/s/line/newline/g' #replaces line0-1-2-etc with newline0-1-2-etc in a file where first line and last line are in format (line0 ... up to lineX)
split to understand: the fine part is /(/,/)/ = /(/ , /)/
insteaf of 'p' at the end we use s/old/new/ for replace.

SED:EXAMPLES BY UNIX SCHOOL
.B See: http://www.theunixschool.com/2014/08/sed-examples-remove-delete-chars-from-line-file.html

SED:DELETE 
##To remove 1st character in every line:
sed 's/^.//' file 
or 
sed  's/.//' file

## To remove last character of every line : 
$ sed 's/.$//' file

## To remove the 1st and last character of every line in the same command: 
$ sed 's/.//;s/.$//' file

## To remove first character only if it is a specific character: 
$ sed 's/^F//' file #Removes Lines starting with F

## To remove last character only if it is a specific character: 
$ sed 's/x$//' file #removes last character if is x

## To remove 1st 3 characters of every line: 
$ sed 's/...//' file #OR# $ sed -r 's/.{3}//' file

## To remove last n characters of every line: 
$ sed -r 's/.{3}$//' file

## To remove everything except the 1st n characters in every line: 
$ sed -r 's/(.{3}).*/\1/' file
.* -> matches any number of characters.
first 3 characters matched are grouped using parantheses. 
In the replacement, by having \1 only the group is retained, leaving out the remaining part.

##  Similarly , to remove everything except the last n characters in a file: 
$ sed -r 's/.*(.{3})/\1/' file

## To remove multiple characters present in a file: 
$ sed 's/[aoe]//g' file

## To remove a pattern  : 
$ sed 's/lari//g' file

## To delete only nth occurrence of a character in every line: 
$ sed 's/u//2' file #replaces two u and stops. /g replaces all . Leave it blank replace only the first found.

## To delete everything in a line followed by a character: 
$ sed 's/a.*//' file #In Word RedHat this Returns RedH

## To remove all digits present in every line of a file: 
$ sed 's/[0-9]//g' file

## To remove all lower case alphabets present in every line: 
$ sed 's/[a-z]//g' file #in word Linux this returns L

## To remove all alpha-numeric characters present in every line: 
$ sed 's/[a-zA-Z0-9]//g' file

## To remove a character irrespective of the case: 
$ sed 's/[uU]//g' file

## Delete a particular line : 
$ sed '1d' file OR  $ sed '3d' file OR $ sed '$d' file (last line) OR sed '2,4d' file (range) OR sed '1d;$d' file (first and last line)
Tip: replace d with !d to invert the action = delete lines other than those with !d.

##Delete all lines beginning with 'L'  /OR/ ending with 'x' character: 
$ sed '/^L/d' file /OR/ sed '/x$/d' file /OR/ sed '/[xX]$/d' file (both x and X) 

##Delete all blank lines in the file
$ sed '/^$/d' file

##Delete all lines which are empty or which contains just some blank spaces:
$ sed '/^ *$/d' file

##Delete the lines containing the pattern 'Unix'.
$ sed '/Unix/d' file #Use !d to delete line NOT containing the pattern Unix.

##Delete the lines containing the pattern 'Unix' OR 'Linux':
$ sed '/Unix\|Linux/d' file #In some sed OR | is not working - use two expressions (not a pipe)

##Delete the lines starting from the 1st line till encountering the pattern 'Linux':
$ sed '1,/Linux/d' file

##Delete the lines starting from the pattern 'Linux' till the last line:
$ sed '/Linux/,$d' file

##Delete the last line ONLY if it contains the pattern 'AIX':
$ sed '${/AIX/d;}' file /OR/ sed '${/AIX\|HPUX/d;}' file (two patterns with or)

##Delete the lines containing the pattern 'Solaris' only if it is present in the lines from 1 to 4.
$ sed '1,4{/Solaris/d;}' file

##Delete the line containing the pattern 'Unix' and also the next line:
$ sed '/Unix/{N;d;}' file
N command reads the next line in the pattern space. d deletes the entire pattern space which contains the current and the next line.

##Delete only the next line containing the pattern 'Unix', not the very line:
$ sed '/Unix/{N;s/\n.*//;}' file
with s/ we delete from the newline character till the end, which effective deletes the next line after the line containing the pattern Unix.

##Delete the line containing the pattern 'Linux', also the line before the pattern:
$ sed -n '/Linux/{s/.*//;x;d;};x;p;${x;p;}' file | sed '/^$/d'

In order to delete the line prior to the pattern,we store every line in a buffer called as hold space. 
Whenever the pattern matches, we delete the content present in both, the pattern space which contains the current line, the hold space which contains the previous line.
'x;p;' ; This gets executed for every line. x exchanges the content of pattern space with hold space. p prints the pattern space. 
As a result, every time, the current line goes to hold space, and the previous line comes to pattern space and gets printed. 
When the pattern /Linux/ matches, we empty(s/.*//) the pattern space, and exchange(x) with the hold space(as a result of which the hold space becomes empty) and delete(d) the pattern space which contains the previous line. 

And hence, the current and the previous line gets deleted on encountering the pattern Linux. The ${x;p;} is to print the last line which will remain in the hold space if left.
The second part of sed is to remove the empty lines created by the first sed command

##Delete only the line prior to the line containing the pattern  'Linux', not the very line:
$  sed -n '/Linux/{x;d;};1h;1!{x;p;};${x;p;}' file

This is almost same as the last one with few changes. On encountering the pattern /Linux/, we exchange(x) and delete(d). As a result of exchange, the current line remains in hold space, and the previous line which came into pattern space got deleted.
1h;1!{x;p;} -  1h is to move the current line to hold space only if it first line. Exchange and print for all the other lines. This could easily have been simply: x;p . The drawback is it gives an empty line at the beginning because during the first exchange between the pattern space and hold space, a new line comes to pattern space since hold space is empty.

## Delete only the line prior to the line containing the pattern  'Linux', not the very line:
$  sed -n '/Linux/{x;d;};1h;1!{x;p;};${x;p;}' file

## Delete the line containing the pattern 'Linux', the line before, the line after:
$ sed -n '/Linux/{N;s/.*//;x;d;};x;p;${x;p;}' file | sed '/^$/d'

## To remove the 1st field or column (comma separated text):
$ sed 's/[^,]*,//' file

## To delete the 2nd field /OR/ To print only the second field
$ sed 's/,[^,]*,/,/' file  /OR/  sed 's/[^,]*,\([^,]*\).*/\1/' file

## delete the first line of the file:
$ sed '1d' file

SED:PRINT 
##Print first / last line of the file: 
$ sed -n '1p' file  / sed -n '$p' file 

## Print lines which does not X / do contain 'ux':
$ sed -n '/X/!p' file / $ sed -n '/[ux]/p' file

## Print lines which end with 'x' or 'X' / Beginning with 'A' or 'L'
$ sed -n '/[xX]$/p' file   /   sed -n '/^A\|^L/p' file
Some sed version does not accept | (or). Use two patterns instead.

## Print every alternate line (skip one line):
$ sed  'n;d' file
n command prints the current line, and immediately reads the next line into pattern space. d command deletes the line present in pattern space. In this way, alternate lines get printed.

Similarly sed  'n;n;N;d' file print every two lines

##Print lines ending with 'X' within a range of lines:
$ sed -n '/Unix/,${/X$/p;}' file

The range of lines being chosen are starting from the line containing the pattern 'Unix' till the end of the file($). The commands present within the braces are applied only for this range of lines. 
Within this group, only the lines ending with 'x' are printed. 
Refer this to know how to print a range of lines using sed from example 5 onwards.

##Print range of lines excluding the starting and ending line of the range:
$ sed -n '/Solaris/,/HPUX/{//!p;}' file
The range of lines chosen is from 'Solaris' to 'HPUX'. 
The action within the braces is applied only for this range of lines. 
If no pattern is provided in pattern matching (//), the last matched pattern is considered. 
For eg, when the line containing the pattern 'Solaris' matches the range of lines and gets inside the curly braches, since no pattern is present, the last pattern (solaris) is matched. 
Since this matching is true, it is not printed(!p), and the same becomes true for the last line in the group as well.

## To print only the last field, OR remove all fields except the last field:
$ sed 's/.*,//' file

##To print only the 1st field:
$ sed 's/,.*//' file

## Print /delete only the line containing 'Gmail'. In other words, to simulate the grep or grep -v command:
$ sed '/Gmail/p' file - For delete use /d instead of /p

##Print lines till you encounter a specific pattern, say till 'Yahoo' is encountered.
$ sed  '/Yahoo/q' file  #q = quit if pattern / expression matched. Without -n option in sed, lines up to Yahoo are printed (default action of sed is to print).

## To print the first 3 lines, or from lines 1 through 3:
$ sed -n '1,3p' file #Alternative : sed '3q' file

##Print the first line of the first file ('one.txt') and the last line of the last file ('three.txt').  
Use '-s' to reverse this behavior.
sed -n  '1p ; $p' one.txt two.txt three.txt
PS: 'sed' treats multiple input files as one long stream.

##Delete lines 30 to 35:
sed '30,35d' input.txt

##Print lines 30 to 35:
sed -n '30,35p' input.txt

##Print all input until a line starting with the word 'foo' is found.
sed '/^foo/q' input.txt

SED:REPLACE 
##To insert a new column at the end(last column) :
$ sed 's/.*/&,A/' file
The regex (.*) matches the entire line and replacing it with the line itself (& also \0 works) and the new field = letter A

##To insert a new column in the beginning(1st column):
$ sed 's/.*/A,&/' file

## To print the entire file contents:
$ sed '' file

## Transileterate - tr simulation. Replace a set of chars with onether set of chars.
echo "All day  and all day" | sed 'y/aA/Bb/'
>bll dBy  Bnd Bll dBy
All character of a will replaced with B
All characters of A will replaced with b
In file usage makes global substitution by default.

## Replace range of lines 2nd to 9th lines with the word 'hello':
sed '2,9c hello'

##Replace the word 'hello' with 'world' only on line 144:
sed '144s/hello/world/' input.txt 

##Replaces the word 'hello' with 'world' only in lines containing the word 'apple':
sed '/apple/s/hello/world/' input.txt

##Replaces the word 'hello' with 'world' only in lines NOT containing the word 'apple':
sed '/apple/!s/hello/world/' input.txt 

##Replaces the word 'hello' with 'world' only in all lines excluding lines 4 to 17:
sed '4,17!s/hello/world/' input.txt

SED:INSERT 
##Insert text to the end of file - after last line
sed -i -e "\$aTEXTTOEND" <filename>
OR
sed '$s/$/texttoend/'
Tip: if instead $a you use i.e 4a text will append to 4th line

##Insert text to the start of file - before first line
The command inserts a tag to the beginning of a file:

sed -i "1s/^/<?php /" file
sed "1i YourTextHere" or sed "1i $h" (with text in variable h)

##Insert text after second line:
sed '2a hello'
Leading whitespaces after the 'a' command are ignored.  The text to add is read until the end of the line.

## Insert text before second line:
sed '2i "George"' a.txt

##Insert text in line before / after pattern
sed '/-----/i "George"' a.txt
i : line before pattern
a : line after pattern

------------------------------------------------------------------------------------------------------------------------------

SED:ONELINER:SCRIPTS FOR SED (Unix stream editor)        Dec. 29, 2005
Compiled by Eric Pement - pemente[at]northpark[dot]edu        version 5.5

Latest version of this file (in English) is usually at:
   http://sed.sourceforge.net/sed1line.txt
   http://www.pement.org/sed/sed1line.txt

SED:ONELINERS:FILE SPACING:
## double space a file
sed G

## double space a file which already has blank lines in it. Output file should contain no more than one blank line between lines of text.
sed '/^$/d;G'

## triple space a file
sed 'G;G'

## undo double-spacing (assumes even-numbered lines are always blank)
sed 'n;d'

## insert a blank line above every line which matches "regex"
sed '/regex/{x;p;x;}'

## insert a blank line below every line which matches "regex"
sed '/regex/G'

## insert a blank line above and below every line which matches "regex"
sed '/regex/{x;p;x;G;}'

SED:ONELINERS:NUMBERING:

## number each line of a file (simple left alignment). Using a tab (see note on '\t' at end of file) instead of space will preserve margins.
sed = filename | sed 'N;s/\n/\t/'

## number each line of a file (number on left, right-aligned)
sed = filename | sed 'N; s/^/     /; s/ *\(.\{6,\}\)\n/\1  /'

## number each line of file, but only print numbers if line is not blank
sed '/./=' filename | sed '/./N; s/\n/ /'

## count lines (emulates "wc -l")
sed -n '$='

SED:ONELINERS:TEXT CONVERSION AND SUBSTITUTION:

## IN UNIX ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format.
sed 's/.$//'               # assumes that all lines end with CR/LF
sed 's/^M$//'              # in bash/tcsh, press Ctrl-V then Ctrl-M
sed 's/\x0D$//'            # works on ssed, gsed 3.02.80 or higher

## IN UNIX ENVIRONMENT: convert Unix newlines (LF) to DOS format.
sed "s/$/`echo -e \\\r`/"            # command line under ksh
sed 's/$'"/`echo \\\r`/"             # command line under bash
sed "s/$/`echo \\\r`/"               # command line under zsh
sed 's/$/\r/'                        # gsed 3.02.80 or higher

## IN DOS ENVIRONMENT: convert Unix newlines (LF) to DOS format.
sed "s/$//"                          # method 1
sed -n p                             # method 2

## IN DOS ENVIRONMENT: convert DOS newlines (CR/LF) to Unix format.
Can only be done with UnxUtils sed, version 4.0.7 or higher. The
UnxUtils version can be identified by the custom "--text" switch
which appears when you use the "--help" switch. Otherwise, changing
DOS newlines to Unix newlines cannot be done with sed in a DOS
environment. Use "tr" instead.

sed "s/\r//" infile >outfile         # UnxUtils sed v4.0.7 or higher
tr -d \r <infile >outfile            # GNU tr version 1.22 or higher

## delete leading whitespace (spaces, tabs) from front of each line aligns all text flush left
sed 's/^[ \t]*//'                    # see note on '\t' at end of file

## delete trailing whitespace (spaces, tabs) from end of each line
sed 's/[ \t]*$//'                    # see note on '\t' at end of file

## delete BOTH leading and trailing whitespace from each line
sed 's/^[ \t]*//;s/[ \t]*$//'

## insert 5 blank spaces at beginning of each line (make page offset)
sed 's/^/     /'

## align all text flush right on a 79-column width
sed -e :a -e 's/^.\{1,78\}$/ &/;ta'  # set at 78 plus 1 space

center all text in the middle of 79-column width. In method 1, spaces at the beginning of the line are significant, and trailing spaces are appended at the end of the line. 
In method 2, spaces at the beginning of the line are discarded in centering the line, and no trailing spaces appear at the end of lines.
sed  -e :a -e 's/^.\{1,77\}$/ & /;ta'                     # method 1
sed  -e :a -e 's/^.\{1,77\}$/ &/;ta' -e 's/\( *\)\1/\1/'  # method 2

## substitute (find and replace) "foo" with "bar" on each line
sed 's/foo/bar/'             # replaces only 1st instance in a line
sed 's/foo/bar/4'            # replaces only 4th instance in a line
sed 's/foo/bar/g'            # replaces ALL instances in a line
sed 's/\(.*\)foo\(.*foo\)/\1bar\2/' # replace the next-to-last case
sed 's/\(.*\)foo/\1bar/'            # replace only the last case

## substitute "foo" with "bar" ONLY for lines which contain "baz"
sed '/baz/s/foo/bar/g'

## substitute "foo" with "bar" EXCEPT for lines which contain "baz"
sed '/baz/!s/foo/bar/g'

## change "scarlet" or "ruby" or "puce" to "red"
sed 's/scarlet/red/g;s/ruby/red/g;s/puce/red/g'   # most seds
gsed 's/scarlet\|ruby\|puce/red/g'                # GNU sed only

## reverse order of lines (emulates "tac")
## bug/feature in HHsed v1.5 causes blank lines to be deleted
sed '1!G;h;$!d'               # method 1
sed -n '1!G;h;$p'             # method 2

## reverse each character on the line (emulates "rev")
sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//'

## join pairs of lines side-by-side (like "paste")
sed '$!N;s/\n/ /'

## if a line ends with a backslash, append the next line to it
sed -e :a -e '/\\$/N; s/\\\n//; ta'

## if a line begins with an equal sign, append it to the previous line and replace the "=" with a single space
sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'

## add commas to numeric strings, changing "1234567" to "1,234,567"
gsed ':a;s/\B[0-9]\{3\}\>/,&/;ta'                     # GNU sed
sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta'  # other seds

## add commas to numbers with decimal points and minus signs (GNU sed)
gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'

## add a blank line every 5 lines (after lines 5, 10, 15, 20, etc.)
gsed '0~5G'                  # GNU sed only
sed 'n;n;n;n;G;'             # other seds

SED:ONELINERS:SELECTIVE PRINTING OF CERTAIN LINES:

## print first 10 lines of file (emulates behavior of "head")
sed 10q

## print first line of file (emulates "head -1")
sed q

## print the last 10 lines of a file (emulates "tail")
sed -e :a -e '$q;N;11,$D;ba'

## print the last 2 lines of a file (emulates "tail -2")
sed '$!N;$!D'

## print the last line of a file (emulates "tail -1")
sed '$!d'                    # method 1
sed -n '$p'                  # method 2

## print the next-to-the-last line of a file
sed -e '$!{h;d;}' -e x              # for 1-line files, print blank line
sed -e '1{$q;}' -e '$!{h;d;}' -e x  # for 1-line files, print the line
sed -e '1{$d;}' -e '$!{h;d;}' -e x  # for 1-line files, print nothing

## print only lines which match regular expression (emulates "grep")
sed -n '/regexp/p'           # method 1
sed '/regexp/!d'             # method 2

## print only lines which do NOT match regexp (emulates "grep -v")
sed -n '/regexp/!p'          # method 1, corresponds to above
sed '/regexp/d'              # method 2, simpler syntax

## print the line immediately before a regexp, but not the line containing the regexp
sed -n '/regexp/{g;1!p;};h'

## print the line immediately after a regexp, but not the line containing the regexp
sed -n '/regexp/{n;p;}'

## print 1 line of context before and after regexp, with line number indicating where the regexp occurred (similar to "grep -A1 -B1")
sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h

## grep for AAA and BBB and CCC (in any order)
sed '/AAA/!d; /BBB/!d; /CCC/!d'

## grep for AAA and BBB and CCC (in that order)
sed '/AAA.*BBB.*CCC/!d'

## grep for AAA or BBB or CCC (emulates "egrep")
sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d    # most seds
gsed '/AAA\|BBB\|CCC/!d'                        # GNU sed only

## print paragraph if it contains AAA (blank lines separate paragraphs)
HHsed v1.5 must insert a 'G;' after 'x;' in the next 3 scripts below
sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'

## print paragraph if it contains AAA and BBB and CCC (in any order)
sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;/BBB/!d;/CCC/!d'

## print paragraph if it contains AAA or BBB or CCC
sed -e '/./{H;$!d;}' -e 'x;/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d
gsed '/./{H;$!d;};x;/AAA\|BBB\|CCC/b;d'         # GNU sed only

## print only lines of 65 characters or longer
sed -n '/^.\{65\}/p'

## print only lines of less than 65 characters
sed -n '/^.\{65\}/!p'        # method 1, corresponds to above
sed '/^.\{65\}/d'            # method 2, simpler syntax

## print section of file from regular expression to end of file
sed -n '/regexp/,$p'

## print section of file based on line numbers (lines 8-12, inclusive)
sed -n '8,12p'               # method 1
sed '8,12!d'                 # method 2

## print line number 52
sed -n '52p'                 # method 1
sed '52!d'                   # method 2
sed '52q;d'                  # method 3, efficient on large files

## beginning at line 3, print every 7th line
gsed -n '3~7p'               # GNU sed only
sed -n '3,${p;n;n;n;n;n;n;}' # other seds

## print section of file between two regular expressions (inclusive)
sed -n '/Iowa/,/Montana/p'             # case sensitive

SED:ONELINERS:SELECTIVE DELETION OF CERTAIN LINES:

## print all of file EXCEPT section between 2 regular expressions
sed '/Iowa/,/Montana/d'

## delete duplicate, consecutive lines from a file (emulates "uniq").
First line in a set of duplicate lines is kept, rest are deleted.
sed '$!N; /^\(.*\)\n\1$/!P; D'

## delete duplicate, nonconsecutive lines from a file. Beware not to overflow the buffer size of the hold space, or else use GNU sed.
sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'

## delete all lines except duplicate lines (emulates "uniq -d").
sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'

## delete the first 10 lines of a file
sed '1,10d'

## delete the last line of a file
sed '$d'

## delete the last 2 lines of a file
sed 'N;$!P;$!D;$d'

## delete the last 10 lines of a file
sed -e :a -e '$d;N;2,10ba' -e 'P;D'   # method 1
sed -n -e :a -e '1,10!{P;N;D;};N;ba'  # method 2

## delete every 8th line
gsed '0~8d'                           # GNU sed only
sed 'n;n;n;n;n;n;n;d;'                # other seds

## delete lines matching pattern
sed '/pattern/d'

## delete ALL blank lines from a file (same as "grep '.' ")
## removes new lines between lines actually
sed '/^$/d'                           # method 1
sed '/./!d'                           # method 2

## delete all CONSECUTIVE blank lines from file except the first; also
## deletes all blank lines from top and end of file (emulates "cat -s")
sed '/./,/^$/!d'          # method 1, allows 0 blanks at top, 1 at EOF
sed '/^$/N;/\n$/D'        # method 2, allows 1 blank at top, 0 at EOF

## delete all CONSECUTIVE blank lines from file except the first 2:
sed '/^$/N;/\n$/N;//D'

## delete all leading blank lines at top of file
sed '/./,$!d'

## delete all trailing blank lines at end of file
sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'  # works on all seds
sed -e :a -e '/^\n*$/N;/\n$/ba'        # ditto, except for gsed 3.02.*

## delete the last line of each paragraph
sed -n '/^$/{p;h;};/./{x;/./p;}'

SED:ONELINERS:SPECIAL APPLICATIONS:


## get Usenet/e-mail message header
sed '/^$/q'                # deletes everything after first blank line

## get Usenet/e-mail message body
sed '1,/^$/d'              # deletes everything up to first blank line

## get Subject header, but remove initial "Subject: " portion
sed '/^Subject: */!d; s///;q'

## get return address header
sed '/^Reply-To:/q; /^From:/h; /./d;g;q'

## parse out the address proper. Pulls out the e-mail address by itself from the 1-line return address header (see preceding script)
sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'

## add a leading angle bracket and space to each line (quote a message)
sed 's/^/> /'

## delete leading angle bracket & space from each line (unquote a message)
sed 's/^> //'

## remove most HTML tags (accommodates multiple-line tags)
sed -e :a -e 's/<[^>]*>//g;/</N;//ba'

## extract multi-part uuencoded binaries, removing extraneous header info, so that only the uuencoded portion remains. 
Files passed to sed must be passed in the proper order. Version 1 can be entered from the command line; version 2 can be made into an executable Unix shell script. (Modified from a script by Rahul Dhesi.)
sed '/^end/,/^begin/d' file1 file2 ... fileX | uudecode   # vers. 1
sed '/^end/,/^begin/d' "$@" | uudecode                    # vers. 2

## sort paragraphs of file alphabetically. Paragraphs are separated by blank lines. GNU sed uses \v for vertical tab, or any unique char will do.
sed '/./{H;d;};x;s/\n/={NL}=/g' file | sort | sed '1s/={NL}=//;s/={NL}=/\n/g'
gsed '/./{H;d};x;y/\n/\v/' file | sort | sed '1s/\v//;y/\v/\n/'

## zip up each .TXT file individually, deleting the source file and setting the name of each .ZIP file to the basename of the .TXT file
(under DOS: the "dir /b" switch returns bare filenames in all caps).
echo @echo off >zipup.bat
dir /b *.txt | sed "s/^\(.*\)\.TXT/pkzip -mo \1 \1.TXT/" >>zipup.bat

SED:ONELINERS:TYPICAL USE: 
Sed takes one or more editing commands and applies all of them, in sequence, to each line of input. 
After all the commands have been applied to the first input line, that line is output and a second input line is taken for processing, and the cycle repeats. 
The preceding examples assume that input comes from the standard input device (i.e, the console, normally this will be piped input). 
One or more filenames can be appended to the command line if the input does not come from stdin. Output is sent to stdout (the screen). 

Thus:

cat filename | sed '10q'        # uses piped input
sed '10q' filename              # same effect, avoids a useless "cat"
sed '10q' filename > newfile    # redirects output to disk

For additional syntax instructions, including the way to apply editing commands from a disk file instead of the command line, consult 
"sed & awk, 2nd Edition," by Dale Dougherty and Arnold Robbins (O'Reilly, 1997; http://www.ora.com), 
"UNIX Text Processing," by Dale Dougherty and Tim O'Reilly (Hayden Books, 1987) 
or the tutorials by Mike Arst distributed in U-SEDIT2.ZIP (many sites). 

To fully exploit the power of sed, one must understand "regular expressions." For this, see "Mastering Regular Expressions" by Jeffrey Friedl (OReilly, 1997).

The manual ("man") pages on Unix systems may be helpful (try "man sed", "man regexp", or the subsection on regular expressions in "man ed"), but man pages are notoriously difficult. 
They are not written to teach sed use or regexps to first-time users, but as a reference text for those already acquainted with these tools.

SED:QUOTING SYNTAX: 
The preceding examples use single quotes ('...') instead of double quotes ("...") to enclose editing commands, since sed is typically used on a Unix platform. 
Single quotes prevent the Unix shell from intrepreting the dollar sign ($) and backquotes (`...`), which are expanded by the shell if they are enclosed in double quotes. 
Users of the "csh" shell and derivatives will also need to quote the exclamation mark (!) with the backslash (i.e., \!) to properly run the examples listed above, even within single quotes.

Versions of sed written for DOS invariably require double quotes ("...") instead of single quotes to enclose editing commands.

SED:USE OF '\t' IN SED SCRIPTS: 
For clarity in documentation, we have used the expression '\t' to indicate a tab character (0x09) in the scripts.
However, most versions of sed do not recognize the '\t' abbreviation, so when typing these scripts from the command line, you should press
the TAB key instead. '\t' is supported as a regular expression metacharacter in awk, perl, and HHsed, sedmod, and GNU sed v3.02.80.

SED:VERSIONS OF SED: 
Versions of sed do differ, and some slight syntax variation is to be expected. In particular, most do not support the use of labels (:name) or branch instructions (b,t) within editing commands, except at the end of those commands. 
We have used the syntax which will be portable to most users of sed, even though the popular GNU versions of sed allow a more succinct syntax. 
When the reader sees a fairly long command such as this:

   sed -e '/AAA/b' -e '/BBB/b' -e '/CCC/b' -e d

it is heartening to know that GNU sed will let you reduce it to:

   sed '/AAA/b;/BBB/b;/CCC/b;d'      # or even
   sed '/AAA\|BBB\|CCC/b;d'

In addition, remember that while many versions of sed accept a command like "/one/ s/RE1/RE2/", some do NOT allow "/one/! s/RE1/RE2/", which contains space before the 's'. 
Omit the space when typing the command.

SED:ONELINERS:OPTIMIZING FOR SPEED: 
If execution speed needs to be increased (due to large input files or slow processors or hard disks), substitution will be executed more quickly if the "find" expression is specified before giving the "s/.../.../" instruction. 

Thus:

   sed 's/foo/bar/g' filename         # standard replace command
   sed '/foo/ s/foo/bar/g' filename   # executes more quickly
   sed '/foo/ s//bar/g' filename      # shorthand sed syntax

On line selection or deletion in which you only need to output lines from the first part of the file, a "quit" command (q) in the script will drastically reduce processing time for large files. 

Thus:

   sed -n '45,50p' filename           # print line nos. 45-50 of a file
   sed -n '51q;45,50p' filename       # same, but executes much faster

If you have any additional scripts to contribute or if you find errors in this document, please send e-mail to the compiler. Indicate the version of sed you used, the operating system it was compiled for, and the nature of the problem. 

## To qualify as a one-liner, the command line must be 65 characters or less. 

Various scripts in this file have been written or contributed by:

SED:ONELINERS:DOCS
More Docs: http://sed.sourceforge.net/
